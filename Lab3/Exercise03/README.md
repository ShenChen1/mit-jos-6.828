# 翻译
```
Basics of Protected Control Transfer

异常和中断都被称作为“保护控制转移”，这会引发处理器从用户态(CPL=3)切换到内核态(CPL=0)，不过对于用户态代码来说，
没有任何机会可以去干扰内核或者其他进程。在Intel的术语中，中断是通常是由处理器外部的异步事件所引发的保护控制转移，
比如说外部I/O活动。而异常则是由当前运行代码导致的同步事件所引发的保护控制转移，比如说除0或是访问非法内存。

为了确保这些保护控制转移能真正起到保护作用，因此设计了处理器的中断/异常机制，以便当中断或异常发生时，
当前正在运行的代码不会随意选择内核进入的位置或方式。在x86上，两种机制共同工作来提供这种保护：

1.The Interrupt Descriptor Table. 
处理器确保中断和异常只能引发内核进入由内核本身决定的几个特定的、定义良好的入口点，同时不会继续执行错误的代码。
x86允许在内核中有256个不同的中断或者异常入口点，每个都有不同的中断向量。向量是一个0~255的值。中断的矢量由中断的源决定：
不同的设备、错误条件和对内核的应用程序请求会使用不同的向量生成中断。CPU使用向量作为处理的中断描述表(IDT)的索引，
IDT是由内核建立的内核私有内存，与GDT相似。处理器加载：
eip：指向处理对应异常类型的内核代码
cs：第0-1位包括要运行异常处理程序的权限级别

2.The Task State Segment.
在中断或者异常发生前，处理器需要有一个地方去保存老的处理器状态，例如在处理器进入异常处理前的eip和cs的原始值，
这样异常处理就可以在最后恢复老的状态，然后继续执行之前被中断代码。但是保存老的处理器转台的区域必须要被保护起来不被用户修改；
不然故障或者恶意的用户代码可以危害到内核

基于这个原因，一个x86处理器处理一个中断或者异常时会引发一个特权等级会从用户模式切换到内核模式，同时也会切换到一个
在内核内存下的栈。一个被称作任务状态段（TSS）的结构体，指定了这个栈生存的对应的段选择子和地址。处理器将ss，esp，eflags，
cs，eip和一个可选的错误码推入这个新的栈中。然后再从中断描述符中加载cs和eip，同时根据新的栈去设置esp和ss。

虽然TSS很大而且有很多用途，但是JOS只使用到它与定义那个处理器应该在从用户模式转换到内核模式时应切换的内核栈。
因此“内核栈”在x86下的JOS中处于特权等级0，当进去内核模式时，处理器使用TSS的esp0和ss0字段去定义内核栈。JOS不使用其他任何TSS字段。

Types of Exceptions and Interrupts

x86处理器内部能够产生的所有同步异常使用中断向量0~31，同时映射到IDT入口的0~31。举个例子，一个page fault总是通过向量14引发异常。
中断向量大于31的只用作于可以由int指令产生的软件中断，或者外部设备引发的异步硬件中断。

```
